#!/usr/bin/env python
from __future__ import print_function, unicode_literals

executable = "/usr/libexec/PlistBuddy"

def parse_args():
    import argparse
    
    class _ChangeExecutableAction(argparse.Action):
        """
        Stores the executable like a standard action, but also changes the global executable.
        This is because the value of this global value may be used in the format_help function.
        """

        def __init__(self, option_strings, dest, nargs=None, **kwargs):
            super(_ChangeExecutableAction, self).__init__(option_strings, dest, **kwargs)

        def __call__(self, parser, namespace, values, option_string=None):
            global executable
            executable = values
            setattr(namespace, self.dest, values)
    
    class ArgumentParser(argparse.ArgumentParser):
        
        def format_help(self):
            """
            Uses a standard format_help, but appends the output of PlistBuddy -h
            """
            help = argparse.ArgumentParser.format_help(self)

            import subprocess
            try:
                man = subprocess.Popen([executable, "-h"], stdout=subprocess.PIPE)
                return help + "\n" + man.stdout.read()
            except subprocess.CalledProcessError:
                return help
    
    parser = ArgumentParser(description="read and write values to plists", epilog="Unless one or more --command or --file parameters get passed in, %(prog)s will run in interactive mode.")
    
    parser.add_argument("-p", "--PlistBuddy", metavar="executable", default=executable, action=_ChangeExecutableAction, help="The location of the PlistBuddy executable. Default is %(default)s")
    parser.add_argument("-c", "--command", dest="commands", metavar="command", default=[], action="append", help="Execute command and exit.")
    parser.add_argument("-x", "--xml", action="store_true", help="Output will be in the form of an xml plist where appropriate.")
    parser.add_argument("-f", "--file", dest="commands", metavar="file", default=[], action="append", type=argparse.FileType("rt"), help="Execute commands from file and exit.")
    parser.add_argument("-S", "--superuser", action="store_true", help="Use sudo to invoke PlistBuddy.")
    parser.add_argument("-E", "--expand-variables", action="store_true", help="Expand environment variables in the form $var or ${var}.")
    parser.add_argument("-v", "--verbose", action="count", help="Show a verbose list of things that are being done.")
    parser.add_argument("plist", metavar="file.plist")

    args = parser.parse_args()
    
    return args

def convert_args_for_plist_buddy(args):
    import os
    result = []
    if args.superuser:
        result.append("/usr/bin/sudo")
    result.append(executable)
    standardencoding = "utf-8"
    
    if args.xml:
        result.append("-x")
    for command in args.commands:
        try:
            lines = command.readlines()
            fileencoding = standardencoding
        except:
            lines = [ command ]
        for line in lines:
            line = line.strip()
            if not line:
                continue
            # don't use startswith because that may throw exceptions if the stripped line does not contain ascii
            if line[0] == "#":
                import re
                # this regular expression is taken from https://www.python.org/dev/peps/pep-0263/
                coding = re.findall(r"^[ \t\v]*#.*?coding[:=][ \t]*([-_.a-zA-Z0-9]+)", line) or [ fileencoding ]
                fileencoding = coding[-1]
                continue
            line = line.decode(fileencoding)
            if args.expand_variables:
                line = os.path.expandvars(line)
            result.append("-c")
            result.append(line)
    result.append(os.path.expanduser(args.plist))
    return result

def main():
    import subprocess
    args = parse_args()
    call_args = convert_args_for_plist_buddy(args)
    if (args.verbose):
        print("Calling {}".format(" ".join('"{}"'.format(i) if " " in i else i for i in call_args)))
    subprocess.call(call_args)
    

if __name__ == "__main__":
    main()
